name: On-Demand ARB Checker

on:
  issues:
    types: [opened, edited]

concurrency:
  group: check-arb-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  check-firmware:
    # Trigger if title starts with [CHECK] and body has a .zip link
    if: (startsWith(github.event.issue.title, '[CHECK]') || contains(github.event.issue.labels.*.name, 'checker')) && contains(github.event.issue.body, '.zip')
    runs-on: ubuntu-latest
    permissions:
      issues: write

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Initial Setup & Label
        id: init
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 1. Add Label
          gh issue edit ${{ github.event.issue.number }} --add-label "checker"
          
          # 2. Extract URL
          URL=$(python3 -c "
          import re, os
          body = '''${{ github.event.issue.body }}'''
          links = re.findall(r'(https?://[^\s]+\.zip(?:[^\s\"\'\(\)\[\]]*)?)', body)
          if links:
              print(links[0])
          ")
          echo "url=$URL" >> $GITHUB_OUTPUT
          
          # 3. Fast Response (Before Tools)
          COMMENT_BODY="ü§ñ **Request Received!**\n\n- [ ] Setting up tools...\n- [ ] Downloading firmware...\n- [ ] Analyzing ARB index...\n\n**URL**: \`$URL\`"
          # Use gh api to create comment and get its ID
          COMMENT_ID=$(gh api -X POST /repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments -f body="$COMMENT_BODY" --jq '.id')
          echo "comment_id=$COMMENT_ID" >> $GITHUB_OUTPUT

      - name: Update Progress (Setup)
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api -X PATCH "/repos/${{ github.repository }}/issues/comments/${{ steps.init.outputs.comment_id }}" -f body=$'ü§ñ **Processing...**\n\n- [x] Setting up tools...\n- [/] Downloading firmware...\n- [ ] Analyzing ARB index...\n\n**URL**: `${{ steps.init.outputs.url }}`'

      - name: Install dependencies & Setup Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y aria2 unzip curl python3-pip
          pip3 install requests beautifulsoup4 --break-system-packages || pip3 install requests beautifulsoup4
          mkdir -p tools
          curl -L -o tools/arbextract https://github.com/koaaN/arbextract/releases/download/1.0/arbextract-x86_64-linux
          chmod +x tools/arbextract
          curl -L -o otaripper.tar.gz https://github.com/syedinsaf/otaripper/releases/download/v2.1.1/otaripper-2.1.1-linux-static-x86_64.tar.gz
          tar -xzvf otaripper.tar.gz
          mv otaripper tools/otaripper || find . -name "otaripper" -type f -exec mv {} tools/otaripper \;
          chmod +x tools/otaripper

      - name: Download Firmware
        run: |
          aria2c -x16 -s16 -k1M -o firmware.zip "${{ steps.init.outputs.url }}"

      - name: Update Progress (Analysing)
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api -X PATCH "/repos/${{ github.repository }}/issues/comments/${{ steps.init.outputs.comment_id }}" -f body=$'ü§ñ **Processing...**\n\n- [x] Setting up tools...\n- [x] Downloading firmware...\n- [/] Analyzing ARB index...\n\n**URL**: `${{ steps.init.outputs.url }}`'

      - name: Analyze Firmware
        id: analyze
        if: hashFiles('firmware.zip') != ''
        run: |
          python3 analyze_firmware.py firmware.zip \
            --tools-dir tools \
            --output-dir extracted \
            --final-dir firmware_data \
            --json > result.json

      - name: Post Final Result (Edit Original Comment)
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_USER: ${{ github.event.issue.user.login }}
        run: |
          if [ ! -f result.json ]; then
            gh api -X PATCH "/repos/${{ github.repository }}/issues/comments/${{ steps.init.outputs.comment_id }}" -f body="‚ùå **Analysis Failed**\nSomething went wrong. The partition \`xbl_config\` was not found or the link is invalid."
            exit 0
          fi
          
          # Create the comment using python and a temporary file to avoid shell escaping issues
          python3 - <<EOF
          import json, os
          res = json.load(open('result.json'))
          arb = res.get('arb_index', 'Unknown')
          status = '‚úÖ **Safe to flash/roll back**' if arb == '0' else '‚ö†Ô∏è **Anti-Rollback Active!**'
          
          meta = res.get('ota_metadata', {})
          device = meta.get('pre-device', 'Unknown')
          product = meta.get('product_name', 'Unknown')
          patch = meta.get('post-security-patch-level', meta.get('security_patch', 'Unknown'))
          version = meta.get('version_name_show', meta.get('display-version', 'Unknown'))
          build = meta.get('post-build', 'Unknown')
          user = os.environ.get('ISSUE_USER', 'user')
          
          output = f"@{user}, here is your analysis!\n"
          output += f"### üëë üéØ Analysis Result\n"
          output += f"- **ARB Index**: \`{arb}\`\n"
          output += f"- **Status**: {status}\n\n"
          output += f"#### üì± Firmware Details\n"
          output += f"- **Version**: \`{version}\`\n"
          output += f"- **Product**: \`{product}\` (\`{device}\`)\n"
          output += f"- **Security Patch**: \`{patch}\`\n"
          output += f"- **Build ID**: \`{build}\`"
          
          with open('comment_body.txt', 'w') as f:
              f.write(output)
          EOF
          
          gh api -X PATCH "/repos/${{ github.repository }}/issues/comments/${{ steps.init.outputs.comment_id }}" --field body="$(cat comment_body.txt)"

      - name: Wait before closing
        if: always()
        run: sleep 180

      - name: Close Issue
        if: always()
        run: |
          gh issue close ${{ github.event.issue.number }} --reason "completed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup
        if: always()
        run: rm -f firmware.zip result.json
